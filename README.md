Client Summary and Software Requirements
For this course, my client was The Gaming Room, who currently offers Draw It or Lose It as an Android-only game. They wanted to expand the game to multiple platforms—including desktop browsers (Linux, Mac, Windows) and mobile devices (iOS and Android)—while maintaining fast, reliable gameplay. The game requires multiple teams and players, enforces strict timing rules for rounds, and renders high-resolution images quickly. The client’s primary concern was that the system be scalable, secure, and able to run multiple simultaneous game instances without conflicts.
Strengths
One area I feel I performed strongly in was translating the client’s requirements into technical solutions. For example, when designing the domain model, I used the singleton pattern for the game service to ensure only one game instance is active at a time. This decision reflects the client’s need to prevent conflicting game states while still allowing multiple games in memory through separate instances. I also spent time explicitly considering cross-platform compatibility, thinking about how memory and storage management would differ between server-side Linux environments versus mobile clients. I feel like I did a solid job connecting high-level client requirements to low-level technical implementation.
Another strength was in the Recommendations section, where I didn’t just list technologies but reflected on their implications. For instance, I analyzed Redis for real-time game state management and PostgreSQL for relational data, connecting each choice to performance, reliability, and scalability. I also carefully thought through security considerations, including TLS/HTTPS encryption, JWT authentication, and input validation—decisions that demonstrate attention to protecting both users and system integrity.
Helpful
Working through the design document made me realize how much planning before coding saves time and prevents mistakes. By mapping out the system architecture, identifying constraints like unique identifiers and memory limits, and creating UML diagrams, I could anticipate challenges that might arise in the code, like ensuring images render quickly or handling multiple users in a distributed system. It also forced me to think about how each platform would behave differently, which helped me consider deployment scenarios realistically rather than theoretically.
For example, I realized that mobile devices could never act as servers for a multi-user game due to memory and storage limitations. I also had to deeply consider how to differentiate between memory and storage management to ensure smooth gameplay. Reflecting on these details gave me a much better sense of how systems actually perform under load and how to design software that is both scalable and user-friendly.
Possible revisions
If I were to revise one part of my work, it would be the Evaluation table comparing operating platforms. While I discussed advantages and disadvantages qualitatively, I think adding quantitative measures, such as estimated server loads, latency expectations, or required memory for handling 200 high-resolution images would make the analysis more actionable. I would also add more visual aids, like charts comparing performance and cost across platforms, to make it easier for a client to quickly grasp the trade-offs.
Interpreting and Implementing User Needs
One of the most challenging and rewarding aspects was putting myself in the users’ shoes. I had to think beyond functionality to consider timing, responsiveness, and gameplay fairness. For example, I implemented memory management strategies in the design to ensure images render smoothly within strict time constraints. I also considered user protection and security, like ensuring sensitive data is encrypted and access is controlled via roles. This exercise reinforced for me why user focused design is essential: even the most technically sophisticated software will fail if it doesn’t meet user expectations for speed, reliability, and usability.
Approach to Designing Software
My approach combined object-oriented design, modular architecture, and platform-specific evaluation. I first outlined the entities and their relationships, then layered in memory, storage, and distributed system considerations. One strategy I found especially useful was thinking through multiple deployment scenarios, like how Linux, Mac, Windows, and mobile clients differ in performance, cost, and technical requirements. In the future, I would expand this by including performance modeling and testing plans, and iteratively refining prototypes based on simulated load and user interaction. I also want to integrate cross-team collaboration strategies, as large scale projects often require coordination between front-end and back-end developers, security specialists, and QA testers.
Overall Reflection
Completing this software design document was an eye-opening experience. It forced me to synthesize technical knowledge, client requirements, and user experience considerations into a coherent plan. I now better understand how critical it is to bridge the gap between technical feasibility and user satisfaction. This process also made me appreciate how much foresight and planning go into software that seems “simple” to the end user, like a drawing game. Most importantly, I’ve learned how to document design decisions thoughtfully, which will make it much easier to maintain and scale software in the future.
